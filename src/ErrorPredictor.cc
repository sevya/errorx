/** Copyright (C) Endeavor Bio, Inc. - All Rights Reserved
Unauthorized copying of this file, via any medium is strictly prohibited
Code contained herein is proprietary and confidential.

@file ErrorPredictor.hh
@brief Runs neural network prediction on DNA sequence features
@details Features of a DNA sequence are generated by SequenceFeatures,
then this class is used to make a NN prediction
@author Alex Sevy (alex.sevy@gmail.com)
*/

#include "ErrorPredictor.hh"
#include "SequenceFeatures.hh"
#include "keras_model.hh"
#include "util.hh"
#include "model.hh"

using namespace std;

namespace errorx {

ErrorPredictor::ErrorPredictor( ErrorPredictor const & other) :
		verbose_( other.verbose_ ),
		keras_model_( model::get_model(), 1, verbose_ )
{}

ErrorPredictor::ErrorPredictor( int verbose ) :
		verbose_( verbose ),
		keras_model_( model::get_model(), 1, verbose_ )
{}

double ErrorPredictor::apply_model( SequenceFeatures const & features ) const {
	using namespace keras;

	if ( features.is_germline() ) return 0.0;
	/**
	12.7.18 AMS I noticed that in several validation sets the
	early positions are consistently where the false positives
	are occurring. This is because in my training data I cut off
	the first 40 bp which are generally unreliable. To get around
	this I introduced this (slightly hacky) solution, where I just
	make anything within the first 13% of the sequence (roughly 40 bp)
	predicted as 0. This greatly improves my precision/recall curves.
	*/
	if ( features.rel_position() < 0.13 ) return 0.0;

	DataScaler scaler;

	const vector<double> scaled_vector = scaler.scale_data( features.get_feature_vector() );

	DataChunkFlat* data = new DataChunkFlat();

	data->set_data( scaled_vector );

	vector<double> output = keras_model_.compute_output( data );

	delete data;

	return output[0];
	
}

vector<double> ErrorPredictor::apply_model( vector<vector<double>> const feature_vector ) const {
	using namespace keras;

	DataChunkFlat* data = new DataChunkFlat();
	DataScaler scaler;

	vector<double> output;

	for ( int ii = 0; ii < feature_vector.size(); ++ii ) {
		const vector<double> scaled_data = scaler.scale_data( feature_vector[ii] );
		data->set_data( scaled_data );
		vector<double> out = keras_model_.compute_output( data );
		output.push_back( out[0] );
	}

	delete data;

	return output;
}

} // namespace errorx
